{"version":3,"file":"deepmerge-json.min.js","sources":["../src/deepmerge-json.js"],"sourcesContent":["const FK = '__proto__';\nconst directReplace = (_, pos) => pos;\nconst shallowCopyArray = (_, pos) => pos.map(e => merge(e));\nconst shallowCopyObj = (_, pos) => {\n\tif (pos && pos.hasOwnProperty('__proto__')) {\n\t\tconst res = {};\n\t\tfor (let e in pos) {\n\t\t\tif (e !== FK) res[e] = pos[e];\n\t\t}\n\t\treturn res;\n\t}\n\treturn Object.assign({}, pos);\n};\n\n// const _clone = (_, pos) => merge(pos);\n\n\nconst mergeObjects = function (pre, pos) {\n\tpre = shallowCopyObj(undefined, pre);\n\tObject.keys(pos).forEach(k => { if (k !== FK) pre[k] = merge(pre[k], pos[k]); });\n\treturn pre;\n};\n\nconst mergeArrays = function (pre, pos) {\n\tpre = shallowCopyArray(undefined, pre);\n\tpos.forEach((v, i) => (pre[i] = merge(pre[i], v)));\n\treturn pre;\n};\n\nconst mergeArrayWithParams = function (pre, pos) {\n\tpre = shallowCopyArray(undefined, pre);\n\tObject.keys(pos).forEach(key => {\n\t\tif (key !== FK) {\n\t\t\tpre = key in arrayMergeFn ? arrayMergeFn[key](pre, pos[key]) : pos;\n\t\t}\n\t});\n\n\treturn pre;\n};\n\nconst indexedReplace = function (pre, pos) {\n\tpre = shallowCopyArray(undefined, pre);\n\tlet kn;\n\tObject.keys(pos).forEach(k => {\n\t\tkn = Number.parseInt(k);\n\t\tif (kn < 0 || Number.isNaN(kn)) throw Error(`Invalid index for $replace: ${k}`);\n\t\tpre[kn] = merge.clone(pos[k]);\n\t});\n\treturn pre;\n};\n\nconst indexedMerge = function (pre, pos) {\n\tpre = pre.slice();\n\tlet kn;\n\tObject.keys(pos).forEach(k => {\n\t\tkn = Number.parseInt(k);\n\t\tif (kn < 0 || Number.isNaN(kn)) throw Error(`Invalid index for $merge: ${k}`);\n\t\tpre[kn] = merge(pre[kn], pos[k]);\n\t});\n\treturn pre;\n};\n\nconst insert = function (pre, pos) {\n\tpre = shallowCopyArray(undefined, pre);\n\tlet kn;\n\tObject.keys(pos).forEach(k => {\n\t\tkn = Number.parseInt(k);\n\t\tif (Number.isNaN(kn)) throw Error(`Invalid index for $insert: ${k}`);\n\t\tpre.splice(kn, 0, pos[k]);\n\t});\n\treturn pre;\n};\n\nconst arrayMergeFn = {\n\t$push: (pre, pos) => pre.concat(pos),\n\t$append: (pre, pos) => pre.concat(pos),\n\t$prepend: (pre, pos) => pos.concat(pre),\n\t$replace: indexedReplace,\n\t$merge: indexedMerge,\n\t$insert: insert,\n\t$set: shallowCopyArray,\t// TODO clone\n};\n\nconst fn = {\n\too: mergeObjects,\n\toa: shallowCopyObj,\t\t// TODO clone\n\tob: directReplace,\n\n\taa: mergeArrays,\n\tao: mergeArrayWithParams,\n\tab: directReplace,\n\n\tbb: directReplace,\n\tbo: shallowCopyObj,\t\t// TODO clone\n\tba: shallowCopyArray,\t// TODO clone\n};\n\n/**\n * Deeply merge objects. Properties from the second parameter overrides the ones with the same path\n * in the first object.\n * \n * Arrays can be merged or changed with `$push`, `$prepend`, `$set`, `$replace` or `$insert`\n * operations. Multiple operations can be passed.\n * \n * @see {@link https://github.com/kleber-swf/deepmerge-json#readme}\n * @param {any} pre Base object\n * @param {any} pos Object that will overrite base properties. If none is given, the first object is\n * \t\t\t  deeply cloned\n * @returns {any} A deep clone object containing a combination of all\n * \t\t\tproperties from pre and pos arguments.\n */\nfunction merge(pre, pos) {\n\tif (pos === undefined) {\n\t\tif (pre == null) return pre;\n\t\tif (Array.isArray(pre)) pos = [];\n\t\telse if (typeof pre === 'object') pos = {};\n\t\telse pos = pre;\n\t} else if (pos === null) {\n\t\treturn null;\n\t}\n\tconst tt = Array.isArray(pre) ? 'a' : typeof pre === 'object' ? 'o' : 'b';\n\tconst st = Array.isArray(pos) ? 'a' : typeof pos === 'object' ? 'o' : 'b';\n\treturn fn[tt + st](pre, pos);\n}\n\n/**\n * Deeply clones an object. This method is an alias to {@linkcode merge} with a single parameter.\n * \n * @template T\n * @param {T} obj The object to be cloned\n * @returns {T} The object passed as parameter deeply cloned.\n */\nmerge.clone = obj => merge(obj);\n\n/**\n * Merges multiple objects. It respects the order of the parameters and the operations just like\n * expected if you call {@linkcode merge} multiple times passing the last result as the first\n * parameter to the next call.\n * \n * @param {any} pre The required first object\n * @param  {...any} args Subsequential objects. Keep in mind that their order matters.\n * @returns {any} A deeply merged object containing all of the parameters\n */\nmerge.multi = (pre, ...args) => {\n\tif (!args) return merge(pre);\n\tfor (let i = 0; i < args.length; i++) {\n\t\tpre = merge(pre, args[i]);\n\t}\n\treturn pre;\n}\n\nexport default merge;\n\n// TODO Test the following approach: clone both objects at the start so we won't need to\n// keep cloning the objects individually during the process.\n// 1. we can clone with JSON.parse(JSON.stringify) and check the __proto__ during the merge\n// 2. we can clone manually and check for __proto__ during this phase"],"names":["FK","directReplace","_","pos","shallowCopyArray","map","e","merge","shallowCopyObj","hasOwnProperty","res","Object","assign","arrayMergeFn","$push","pre","concat","$append","$prepend","$replace","kn","undefined","keys","forEach","k","Number","parseInt","isNaN","Error","clone","$merge","slice","$insert","splice","$set","fn","oo","oa","ob","aa","v","i","ao","key","ab","bb","bo","ba","Array","isArray","tt","st","obj","multi","args","length"],"mappings":"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"}